// Code generated by goa v3.10.2, DO NOT EDIT.
//
// files HTTP client CLI support package
//
// Command:
// $ goa gen starter-pack-goa/design

package client

import (
	"encoding/json"
	"fmt"
	files "starter-pack-goa/gen/files"
	"unicode/utf8"

	goa "goa.design/goa/v3/pkg"
)

// BuildImportFilePayload builds the payload for the files importFile endpoint
// from CLI flags.
func BuildImportFilePayload(filesImportFileBody string, filesImportFileOauth string, filesImportFileJWTToken string) (*files.ImportFilePayload, error) {
	var err error
	var body ImportFileRequestBody
	{
		err = json.Unmarshal([]byte(filesImportFileBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"content\": \"TmFtIGFiIHJlaWNpZW5kaXMgdGVtcG9yZSBldCBwYXJpYXR1ciB1dC4=\",\n      \"filename\": \"foo.jpg\",\n      \"format\": \"image/jpeg\",\n      \"h\": 4017343155180222301,\n      \"mime\": \"Repellendus debitis ut natus repellat ipsa eveniet.\",\n      \"size\": 8756228599422910954,\n      \"url\": \"Est blanditiis.\",\n      \"w\": 453901555597122463\n   }'")
		}
		if body.Content == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("content", "body"))
		}
		if utf8.RuneCountInString(body.Filename) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.filename", body.Filename, utf8.RuneCountInString(body.Filename), 2, true))
		}
		if !(body.Format == "image/jpeg" || body.Format == "image/png" || body.Format == "image/jpg") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", body.Format, []interface{}{"image/jpeg", "image/png", "image/jpg"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var oauth *string
	{
		if filesImportFileOauth != "" {
			oauth = &filesImportFileOauth
		}
	}
	var jwtToken *string
	{
		if filesImportFileJWTToken != "" {
			jwtToken = &filesImportFileJWTToken
		}
	}
	v := &files.ImportFilePayload{
		Filename: body.Filename,
		URL:      body.URL,
		W:        body.W,
		H:        body.H,
		Mime:     body.Mime,
		Content:  body.Content,
		Size:     body.Size,
		Format:   body.Format,
	}
	v.Oauth = oauth
	v.JWTToken = jwtToken

	return v, nil
}

// BuildDeleteFilePayload builds the payload for the files deleteFile endpoint
// from CLI flags.
func BuildDeleteFilePayload(filesDeleteFileBody string, filesDeleteFileOauth string, filesDeleteFileJWTToken string) (*files.DeleteFilePayload, error) {
	var err error
	var body DeleteFileRequestBody
	{
		err = json.Unmarshal([]byte(filesDeleteFileBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"url\": \"/public/uploads/2021/12/2ca51d10-b660-4b2c-b27f-f7a119642885.png\"\n   }'")
		}
		if utf8.RuneCountInString(body.URL) < 23 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.url", body.URL, utf8.RuneCountInString(body.URL), 23, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var oauth *string
	{
		if filesDeleteFileOauth != "" {
			oauth = &filesDeleteFileOauth
		}
	}
	var jwtToken *string
	{
		if filesDeleteFileJWTToken != "" {
			jwtToken = &filesDeleteFileJWTToken
		}
	}
	v := &files.DeleteFilePayload{
		URL: body.URL,
	}
	v.Oauth = oauth
	v.JWTToken = jwtToken

	return v, nil
}
