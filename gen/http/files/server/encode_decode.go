// Code generated by goa v3.5.2, DO NOT EDIT.
//
// files HTTP server encoders and decoders
//
// Command:
// $ goa gen api_crud/design

package server

import (
	files "api_crud/gen/files"
	"context"
	"io"
	"net/http"
	"strings"

	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeImportFileResponse returns an encoder for responses returned by the
// files importFile endpoint.
func EncodeImportFileResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*files.ImportFileResult)
		enc := encoder(ctx, w)
		body := NewImportFileResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeImportFileRequest returns a decoder for requests sent to the files
// importFile endpoint.
func DecodeImportFileRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var payload *files.ImportFilePayload
		if err := decoder(r).Decode(&payload); err != nil {
			return nil, goa.DecodePayloadError(err.Error())
		}
		if payload.Oauth != nil {
			if strings.Contains(*payload.Oauth, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Oauth, " ", 2)[1]
				payload.Oauth = &cred
			}
		}
		if payload.JWTToken != nil {
			if strings.Contains(*payload.JWTToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWTToken, " ", 2)[1]
				payload.JWTToken = &cred
			}
		}

		return payload, nil
	}
}

// NewFilesImportFileDecoder returns a decoder to decode the multipart request
// for the "files" service "importFile" endpoint.
func NewFilesImportFileDecoder(mux goahttp.Muxer, filesImportFileDecoderFn FilesImportFileDecoderFunc) func(r *http.Request) goahttp.Decoder {
	return func(r *http.Request) goahttp.Decoder {
		return goahttp.EncodingFunc(func(v interface{}) error {
			mr, merr := r.MultipartReader()
			if merr != nil {
				return merr
			}
			p := v.(**files.ImportFilePayload)
			if err := filesImportFileDecoderFn(mr, p); err != nil {
				return err
			}

			var (
				oauth    *string
				jwtToken *string
			)
			oauthRaw := r.Header.Get("Authorization")
			if oauthRaw != "" {
				oauth = &oauthRaw
			}
			jwtTokenRaw := r.Header.Get("jwtToken")
			if jwtTokenRaw != "" {
				jwtToken = &jwtTokenRaw
			}
			(*p).Oauth = oauth
			(*p).JWTToken = jwtToken
			return nil
		})
	}
}

// EncodeImportFileError returns an encoder for errors returned by the
// importFile files endpoint.
func EncodeImportFileError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "unknown_error":
			res := v.(*files.UnknownError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewImportFileUnknownErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteFileResponse returns an encoder for responses returned by the
// files deleteFile endpoint.
func EncodeDeleteFileResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*files.DeleteFileResult)
		enc := encoder(ctx, w)
		body := NewDeleteFileResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteFileRequest returns a decoder for requests sent to the files
// deleteFile endpoint.
func DecodeDeleteFileRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body DeleteFileRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateDeleteFileRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			oauth    *string
			jwtToken *string
		)
		oauthRaw := r.Header.Get("Authorization")
		if oauthRaw != "" {
			oauth = &oauthRaw
		}
		jwtTokenRaw := r.Header.Get("jwtToken")
		if jwtTokenRaw != "" {
			jwtToken = &jwtTokenRaw
		}
		payload := NewDeleteFilePayload(&body, oauth, jwtToken)
		if payload.Oauth != nil {
			if strings.Contains(*payload.Oauth, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Oauth, " ", 2)[1]
				payload.Oauth = &cred
			}
		}
		if payload.JWTToken != nil {
			if strings.Contains(*payload.JWTToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWTToken, " ", 2)[1]
				payload.JWTToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteFileError returns an encoder for errors returned by the
// deleteFile files endpoint.
func EncodeDeleteFileError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "unknown_error":
			res := v.(*files.UnknownError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteFileUnknownErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalFilesResFileToResFileResponseBody builds a value of type
// *ResFileResponseBody from a value of type *files.ResFile.
func marshalFilesResFileToResFileResponseBody(v *files.ResFile) *ResFileResponseBody {
	res := &ResFileResponseBody{
		ID:   v.ID,
		Name: v.Name,
		URL:  v.URL,
		Mime: v.Mime,
		Size: v.Size,
	}

	return res
}
